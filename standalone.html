<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Particle Hand Game - Standalone</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        font-family: 'Arial', sans-serif;
      }
      
      #app {
        width: 100vw;
        height: 100vh;
        position: relative;
      }
      
      #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }
      
      #videoElement {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 200px;
        height: 150px;
        border: 2px solid #fff;
        border-radius: 10px;
        z-index: 2;
        transform: scaleX(-1);
      }
      
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        z-index: 3;
        font-size: 14px;
      }
      
      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 24px;
        z-index: 4;
      }
      
      .instructions {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        text-align: center;
        z-index: 4;
        background: rgba(0, 0, 0, 0.8);
        padding: 30px;
        border-radius: 15px;
        backdrop-filter: blur(10px);
        max-width: 80%;
        border: 2px solid rgba(255, 255, 255, 0.2);
      }
      
      .instructions.hidden {
        display: none;
      }
      
      .control-btn {
        background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
        border: none;
        color: white;
        padding: 12px 24px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        margin: 10px 5px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }
      
      .control-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }
      
      .demo-mode {
        margin-top: 20px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
      
      @media (max-width: 768px) {
        #videoElement {
          width: 120px;
          height: 90px;
        }
        
        #ui {
          font-size: 12px;
        }
        
        .instructions {
          font-size: 14px;
          padding: 20px;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <canvas id="gameCanvas"></canvas>
      <video id="videoElement" autoplay muted playsinline style="display: none;"></video>
      <div id="ui">
        <div>FPS: <span id="fps">0</span></div>
        <div>Particles: <span id="particleCount">0</span></div>
        <div>Mode: <span id="currentMode">Touch</span></div>
      </div>
      
      <div id="instructions" class="instructions">
        <h2>üéÆ Particle Hand Game</h2>
        <p><strong>Demo Mode - Touch Controls</strong></p>
        <p>üñ±Ô∏è <strong>Click & Drag:</strong> Attract particles</p>
        <p>üì± <strong>Touch & Drag:</strong> Control particles on mobile</p>
        <p>üé® <strong>Multiple Touches:</strong> Create multiple attraction points</p>
        
        <div class="demo-mode">
          <h3>üöÄ Full Experience</h3>
          <p>For the complete hand tracking experience:</p>
          <p>1. Install Node.js and npm</p>
          <p>2. Run: <code>npm install && npm run dev</code></p>
          <p>3. Allow camera access for hand gestures</p>
        </div>
        
        <button id="startBtn" class="control-btn">Start Demo</button>
      </div>
      
      <div id="loading" class="loading" style="display: none;">Initializing...</div>
    </div>

    <script>
      // Enhanced particle system matching the main game
      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.speedX = Math.random() * 3 - 1.5;
          this.speedY = Math.random() * 3 - 1.5;
          this.size = Math.random() * 8 + 1;
          this.life = Math.random() * 100 + 50;
          this.opacity = 1;

          // Palet warna yang cerah dan menarik
          const colors = [
            '#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66',
            '#F08A5D', '#B83B5E', '#6A2C70', '#FF6B6B',
            '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'
          ];
          this.color = colors[Math.floor(Math.random() * colors.length)];
        }

        update(dt, attractors) {
          // Apply attractor forces
          for (const attractor of attractors) {
            const dx = attractor.x - this.x;
            const dy = attractor.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0 && dist < 300) {
              const force = 2000 / (dist * dist);
              this.speedX += (dx / dist) * force * dt;
              this.speedY += (dy / dist) * force * dt;
            }
          }

          // Update position
          this.x += this.speedX;
          this.y += this.speedY;

          // Apply drag
          this.speedX *= 0.98;
          this.speedY *= 0.98;

          // Boundary bounce
          if (this.x < 0 || this.x > window.innerWidth) this.speedX *= -0.8;
          if (this.y < 0 || this.y > window.innerHeight) this.speedY *= -0.8;

          this.x = Math.max(0, Math.min(window.innerWidth, this.x));
          this.y = Math.max(0, Math.min(window.innerHeight, this.y));

          // Mengurangi ukuran partikel seiring waktu untuk efek menyusut
          if (this.size > 0.2) {
            this.size -= 0.1;
          }

          // Mengurangi waktu hidup dan opacity
          this.life -= 1;
          if (this.life < 50) {
            this.opacity = this.life / 50;
          }
          if (this.opacity < 0) this.opacity = 0;
        }

        render(ctx) {
          if (this.life <= 0 || this.opacity <= 0) return;

          ctx.save();
          ctx.globalAlpha = this.opacity;

          // Parse hex color to RGB for gradient
          const hex = this.color.replace('#', '');
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);

          // Render particle with glow effect
          const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
          gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 1)`);
          gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.5)`);
          gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
          ctx.fill();

          // Inner bright core
          ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size * 0.3, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }

        reset(x, y) {
          this.x = x;
          this.y = y;
          this.speedX = Math.random() * 3 - 1.5;
          this.speedY = Math.random() * 3 - 1.5;
          this.size = Math.random() * 8 + 1;
          this.life = Math.random() * 100 + 50;
          this.opacity = 1;

          const colors = [
            '#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66',
            '#F08A5D', '#B83B5E', '#6A2C70', '#FF6B6B',
            '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'
          ];
          this.color = colors[Math.floor(Math.random() * colors.length)];
        }
      }

      class Game {
        constructor() {
          this.canvas = document.getElementById('gameCanvas');
          this.ctx = this.canvas.getContext('2d');
          this.particles = [];
          this.attractors = [];
          this.isRunning = false;
          this.lastTime = 0;
          this.fps = 0;
          this.frameCount = 0;
          this.lastFpsTime = 0;
          
          this.setupCanvas();
          this.setupInput();
          this.initParticles();
        }

        setupCanvas() {
          const resize = () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
          };
          resize();
          window.addEventListener('resize', resize);
        }

        setupInput() {
          const getPos = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            return {
              x: (e.clientX || e.touches[0].clientX) - rect.left,
              y: (e.clientY || e.touches[0].clientY) - rect.top
            };
          };

          // Mouse events
          this.canvas.addEventListener('mousedown', (e) => {
            const pos = getPos(e);
            this.attractors.push(pos);
          });

          this.canvas.addEventListener('mousemove', (e) => {
            if (e.buttons > 0) {
              const pos = getPos(e);
              this.attractors = [pos];
            }
          });

          this.canvas.addEventListener('mouseup', () => {
            this.attractors = [];
          });

          // Touch events
          this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.attractors = [];
            for (let touch of e.touches) {
              const pos = getPos({clientX: touch.clientX, clientY: touch.clientY});
              this.attractors.push(pos);
            }
          });

          this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            this.attractors = [];
            for (let touch of e.touches) {
              const pos = getPos({clientX: touch.clientX, clientY: touch.clientY});
              this.attractors.push(pos);
            }
          });

          this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.attractors = [];
          });
        }

        initParticles() {
          const count = Math.min(200, Math.floor(window.innerWidth * window.innerHeight / 5000));
          for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(
              Math.random() * window.innerWidth,
              Math.random() * window.innerHeight
            ));
          }
        }

        start() {
          this.isRunning = true;
          this.lastTime = performance.now();
          this.gameLoop();
        }

        gameLoop = (currentTime) => {
          if (!this.isRunning) return;

          const deltaTime = (currentTime - this.lastTime) / 1000;
          this.lastTime = currentTime;

          // Calculate FPS
          this.frameCount++;
          if (currentTime - this.lastFpsTime >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsTime));
            this.frameCount = 0;
            this.lastFpsTime = currentTime;
            this.updateUI();
          }

          this.update(deltaTime);
          this.render();

          requestAnimationFrame(this.gameLoop);
        };

        update(dt) {
          // Spawn new particles occasionally
          if (Math.random() < 0.02 && this.particles.length < 300) {
            this.particles.push(new Particle(
              Math.random() * window.innerWidth,
              Math.random() * window.innerHeight
            ));
          }

          // Update particles
          for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            particle.update(dt, this.attractors);
            
            if (particle.life <= 0) {
              particle.reset(
                Math.random() * window.innerWidth,
                Math.random() * window.innerHeight
              );
            }
          }
        }

        render() {
          // Animated background
          const time = performance.now() * 0.001;
          const gradient = this.ctx.createRadialGradient(
            window.innerWidth / 2 + Math.sin(time * 0.5) * 100,
            window.innerHeight / 2 + Math.cos(time * 0.3) * 100,
            0,
            window.innerWidth / 2,
            window.innerHeight / 2,
            Math.max(window.innerWidth, window.innerHeight)
          );

          gradient.addColorStop(0, `rgba(${Math.sin(time * 0.2) * 20 + 10}, ${Math.cos(time * 0.3) * 20 + 10}, ${Math.sin(time * 0.1) * 30 + 20}, 0.8)`);
          gradient.addColorStop(0.5, 'rgba(5, 5, 15, 0.9)');
          gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');

          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Render particles
          this.ctx.globalCompositeOperation = 'screen';
          for (const particle of this.particles) {
            particle.render(this.ctx);
          }
          this.ctx.globalCompositeOperation = 'source-over';

          // Render attractors
          for (const attractor of this.attractors) {
            const gradient = this.ctx.createRadialGradient(attractor.x, attractor.y, 0, attractor.x, attractor.y, 50);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(attractor.x, attractor.y, 50, 0, Math.PI * 2);
            this.ctx.fill();
          }
        }

        updateUI() {
          document.getElementById('fps').textContent = this.fps;
          document.getElementById('particleCount').textContent = this.particles.length;
        }
      }

      // Initialize game
      const game = new Game();
      
      document.getElementById('startBtn').addEventListener('click', () => {
        document.getElementById('instructions').classList.add('hidden');
        game.start();
        console.log('üéÆ Particle Hand Game Demo Started!');
        console.log('üñ±Ô∏è Click and drag to attract particles');
        console.log('üì± Use touch on mobile devices');
      });
    </script>
  </body>
</html>
